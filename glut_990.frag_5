#version 130

// glut_990_common.glsl
const float dissipation 	= 0.95;

const float ballRadius		= 0.06;
const float fogHeigth		= ballRadius * 2.;
const int	nbSlice			= 32;
const float fogSlice		= fogHeigth / float(nbSlice);
const int	nbSphere 		= 3;
const float ShadowDensity 	= 25.;
const float FogDensity 		= 20.;

const float tau =  radians(360.);

vec2
rotate (float angle, float radius)
{
  return vec2(cos(angle),-sin(angle)) * radius;
}

bool
floorIntersect (vec3 ro, vec3 rd, float floorHeight, out float t)
{
  ro.y -= floorHeight;
  if(rd.y < -0.01)
  {
    t = ro.y / - rd.y;
    return true;
  }

  return false;
} 

vec2
sphIntersect (vec3 ro, vec3 rd, vec3 ce, float ra)
{
  vec3 oc = ro - ce;
  float b = dot( oc, rd );
  float c = dot( oc, oc ) - ra*ra;
  float h = b*b - c;
  if ( h<0.0 ) return vec2(-1.0);
  h = sqrt( h );

  return vec2( -b-h, -b+h );
}

vec2
boxIntersection (vec3 ro, vec3 rd, vec3 rad, vec3 center, out vec3 oN)
{
  ro -= center;
  vec3 m = 1.0/rd;
  vec3 n = m*ro;
  vec3 k = abs(m)*rad;
  vec3 t1 = -n - k;
  vec3 t2 = -n + k;

  float tN = max( max( t1.x, t1.y ), t1.z );
  float tF = min( min( t2.x, t2.y ), t2.z );

  if( tN>tF || tF<0.0) return vec2(-1.0);

  oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);

  return vec2( tN, tF );
}
// glut_990_common.glsl

uniform vec2 iResolution;
uniform float iTime;
uniform vec4 iMouse;
uniform sampler2D iChannel0;

#define RENDER3D 1

#if RENDER3D

#define AA 0

float
sceneIntersection (vec3 ro, vec3 rd, out vec3 inter, out vec3 normal, out vec3 color, float dist)
{
  float mint = dist;
  inter = vec3(0.);
  normal = vec3(0.);
  color = vec3(0.);

  for(int i = 0 ; i < nbSphere ; i++)
  {
    vec2 p2d = rotate(float(i) * tau / float(nbSphere) + iTime * 0.2, 0.8);
    vec3 pos = vec3(p2d.x, ballRadius, p2d.y);
    
    float t = sphIntersect( ro, rd, pos, ballRadius).x;
    if(t > 0. && t < mint)
    {
      mint = t;
      inter = (ro + mint * rd);
      normal = normalize(inter - pos);
      color = vec3(1, 0, 0);
    }     
  }

  float aspecRatio = iResolution.x / iResolution.y;  
  vec3 boxNormal;
  float t = boxIntersection(ro, rd, vec3(aspecRatio,0.1,1), vec3(0,-0.1,0),boxNormal).x;
  if(t > 0. && t < mint)
  {
    mint = t;
    inter = (ro + mint * rd);
    normal = boxNormal;
    ivec2 tileId = ivec2(vec2(inter.x, inter.z) * 3. + 100.);
    color = ((tileId.x & 1) ^ (tileId.y & 1)) == 0 ? vec3(0.3) : vec3(0.15);  
  }       

  return mint;
}

float
sampleFog (vec3 pos)
{
  vec2 uv = pos.xz;
  uv.x *= iResolution.y / iResolution.x;
  uv = uv * 0.5 + 0.5;
  if(max(uv.x, uv.y) > 1. || min(uv.x, uv.y) < 0.)
    return 0.;

  return texture(iChannel0, uv).z;
}

vec3
Render (vec3 ro, vec3 rd, float dist)
{
  vec3  inter;
  vec3  normal;
  vec3  baseColor; 

  float mint = sceneIntersection(ro, rd, inter, normal, baseColor, dist);

  vec3 color = vec3(0);
  vec3 lightDir = normalize(vec3(0.1, 1, 0.7));
  vec3 shadowStep = (fogHeigth / float(nbSlice)) * lightDir / lightDir.y;

  if(mint<dist)
  {
    float shadowDist = 0.;
    for(int i = 0 ; i < nbSlice ; i++)
    {
        vec3 shadowPos = inter + shadowStep * float(i);
        float v = sampleFog(shadowPos) * fogHeigth;
        shadowDist += min(max(0., v - shadowPos.y), fogSlice) * length(shadowStep) / fogSlice;
    }
    float shadowFactor = exp(-shadowDist * ShadowDensity * 0.25);
    color = baseColor * (max(0., dot(normal, lightDir) * shadowFactor) + 0.2);
  }
  else
    color = vec3(0);

  float t;
  if(floorIntersect(ro, rd, fogHeigth, t))
  {
    vec3 curPos = ro + rd * t;
    vec3 fogStep = (fogHeigth / float(nbSlice)) * rd / abs(rd.y);
    float stepLen = length(fogStep);
    float curDensity = 0.;
    float transmittance = 1.;
    float lightEnergy = 0.;
    for(int i = 0; i < nbSlice; i++)
    {
      if( dot(curPos - ro, rd) > mint)
        break;
      float curHeigth = sampleFog(curPos) * fogHeigth;
      float curSample = min(max(0., curHeigth - curPos.y), fogSlice) * stepLen / fogSlice;
      if(curSample > 0.001)
      {
        vec3 shadowPos = curPos;
        float shadowDist = 0.;

        for (int j = 0; j < nbSlice; j++)
        {
          shadowPos += shadowStep;
          if(shadowPos.y > fogHeigth)
            break;
          float curHeight = sampleFog(shadowPos) * fogHeigth;
          shadowDist += min(max(0., curHeight - shadowPos.y), fogSlice) * length(shadowStep) / fogSlice;
        }

        float shadowFactor = exp(-shadowDist * ShadowDensity);
        curDensity = curSample * FogDensity;
        float absorbedlight =  shadowFactor * (1. * curDensity);
        lightEnergy += absorbedlight * transmittance;
        transmittance *= 1. - curDensity;	
      }
      curPos+= fogStep;       
    }
    color = mix(color, vec3(lightEnergy), 1. - transmittance);
  }

  return color;
}

vec3
vignette (vec3 color, vec2 q, float v)
{
  color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);

  return color;
}

mat3
setCamera (vec3 ro, vec3 ta)
{
  vec3 cw = normalize(ta-ro);
  vec3 up = vec3(0, 1, 0);
  vec3 cu = normalize( cross(cw,up) );
  vec3 cv = normalize( cross(cu,cw) );

  return mat3( cu, cv, cw );
}

void
main ()
{
  vec3 tot = vec3(0.0);

#if AA
  vec2 rook[4];
  rook[0] = vec2( 1./8., 3./8.);
  rook[1] = vec2( 3./8.,-1./8.);
  rook[2] = vec2(-1./8.,-3./8.);
  rook[3] = vec2(-3./8., 1./8.);
  for( int n=0; n<4; ++n )
  {
    vec2 o = rook[n];
    vec2 p = (-iResolution + 2.0*(gl_FragCoord.xy+o))/iResolution.y;
#else //AA
    vec2 p = (-iResolution + 2.0 * gl_FragCoord.xy) / iResolution.y;
#endif //AA
 
    float theta	= radians(360.)*(iMouse.x/iResolution.x-0.5) - radians(90.);
    float phi	= -radians(30.);
    vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));
    vec3 ta = vec3( 0 );
    mat3 ca = setCamera( ro, ta );

    vec3 rd =  ca*normalize(vec3(p,1.5));        

    vec3 col = Render(ro ,rd, 6.);

    tot += col;
#if AA
  }
  tot /= 4.;
#endif
  tot = vignette(tot, gl_FragCoord.xy / iResolution, 0.6);
  gl_FragColor = vec4( sqrt(tot), 1.0 );
}
#else
void
main ()
{
  gl_FragColor = vec4(vec3(texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0).z), 1);
}
#endif	// RENDER3D
