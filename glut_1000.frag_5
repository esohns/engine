#version 130

// glut_1000_common.glsl
struct ColorTheme
{
  vec3 colorX;
  vec3 colorY;
  vec3 colorZ;
  vec3 diffuseColor;
  vec3 specularColor;
  vec3 lightDirection;
  float specularPower;
  float lightIntensity;
};

#define KERNEL_CONVOLUTION_SIZE_HIGH 6.0

#define uAntiAliasingLevel 4

#define uMouseAngle 5.0
#define uMouseFactor -0.2
#define uMouseScale 10.0

#define uRotationAngle 1.5
#define uRotationIntensity 0.4

#define uTimeStart 7.5
#define uThemeVariationSpeed 0.05
#define uNormalDirection 1.0

#define uBufferMove iChannel0
#define uBufferProp iChannel1
#define uBufferNorm iChannel2
#define uBufferTrail iChannel3

#define getMove(coord) texture(uBufferMove,(coord)/iResolution)
#define getProp(coord) texture(uBufferProp,(coord)/iResolution)
#define getNorm(coord) texture(uBufferNorm,(coord)/iResolution)
#define getTrail(coord) texture(uBufferTrail,(coord)/iResolution)

const int uKernelRadius = 6;
const float normKernRad = 3.0 / float(uKernelRadius);

const vec2 RESET_ACTION_CELL = vec2(0,0);
const vec2 DRAW_MODE_ACTION_CELL = vec2(1,0);
const vec2 THEME_MODE_ACTION_CELL = vec2(2,0);
const vec2 CURRENT_THEME_CELL = vec2(3,0);

const int KEY_RESET_VIEW   = 32; // Space Key : Reset canvas and animation
const int KEY_DRAW_MODE    = 68; // D key     : switching between auto/free draw mode
const int KEY_THEME_MODE   = 82; // R key     : switching between auto/select theme mode
const int KEY_SWITCH_THEME = 84; // T key     : switch all available themes

const int ThemesCount = 3;
const ColorTheme[] THEMES_ARRAY = ColorTheme[] (
  ColorTheme(
    vec3(0,1,0),
    vec3(0,0,1),
    vec3(1,1,1),
    vec3(0.6,0.6,0),            
    vec3(0.3,0.6,0.8),         
    vec3(0.1,-1.0,0.5),       
    8.0,        
    0.6
  ),
  ColorTheme(
    vec3(1,1,1),
    vec3(0,0.4,1),
    vec3(0.6,0.9,1.0),
    vec3(1.0,0.3,0.1),            
    vec3(0.3,0.6,0.8),         
    vec3(0.1,-1.0,0.5),       
    8.0,        
    0.6       
  ),
  ColorTheme(
    vec3(0,1,0),
    vec3(1,1,1),
    vec3(1,1,1),
    vec3(0.2,1.0,0.2),             
    vec3(0.3,0.6,0.8),        
    vec3(0.1,-1.0,0.5),       
    8.0,        
    0.6       
  )
);

bool isInside (vec2 p, vec2 c) { vec2 d = abs(p-0.5-c) - 0.5; return (-max(d.x,d.y) > 0.0); }

vec2
rotateVector (vec2 vector_, float angleInRadians)
{
  float cosAngle = cos(angleInRadians);
  float sinAngle = sin(angleInRadians);
  return vec2(
    vector_.x * cosAngle - vector_.y * sinAngle,
    vector_.x * sinAngle + vector_.y * cosAngle
  );
}                           

float
getGaussWeight (vec2 p, float k)
{
  return exp(k-dot(p, p));
}

ColorTheme
mixColorTheme (ColorTheme a, ColorTheme b, float ratio)
{
  ColorTheme ret;
  ret.colorX = mix(a.colorX, b.colorX, vec3(ratio));
  ret.colorY = mix(a.colorY, b.colorY, vec3(ratio));
  ret.colorZ = mix(a.colorZ, b.colorZ, vec3(ratio));
  ret.diffuseColor = mix(a.diffuseColor, b.diffuseColor, vec3(ratio));
  ret.specularColor = mix(a.specularColor, b.specularColor, vec3(ratio));
  ret.lightDirection = mix(a.lightDirection, b.lightDirection, vec3(ratio));
  ret.specularPower = mix(a.specularPower, b.specularPower, ratio);
  ret.lightIntensity = mix(a.lightIntensity, b.lightIntensity, ratio);

  return ret;
}

float
getThemeMixingRatio (float time)
{
  float lim = max(float(ThemesCount - 0), 1.0);
  time = (time * uThemeVariationSpeed - lim * 3.14159 / 2.0) / lim;

  return (sin(time) * 0.5 + 0.5) * lim;
}
// glut_1000_common.glsl

uniform vec2 iResolution;
uniform sampler2D iChannel3;

vec4 loadValue (vec2 re) { return texture( uBufferTrail, (0.5+re) / iResolution, -100.0 ); }

ColorTheme
getTheme (int idx)
{
  return THEMES_ARRAY[idx % ThemesCount];        
}

ColorTheme
getBlendedTheme ()
{
  float value = loadValue(CURRENT_THEME_CELL).w;  
  float ratio = fract(value);
  int themeIdx = int(floor(value));
  ColorTheme ret = getTheme(themeIdx);
  if (loadValue(THEME_MODE_ACTION_CELL).w < 0.5)
    ret = mixColorTheme(ret, getTheme(themeIdx + 1), ratio);  
  return ret;
}

void
main ()
{
  gl_FragColor = vec4(0.);
  vec2 g = gl_FragCoord.xy;

  ColorTheme theme = getBlendedTheme();

  float pixelSize = 1.0 / iResolution.y;
  const int AA = uAntiAliasingLevel;
  for(int x=-AA; x<AA; x++)
    for(int y=-AA; y<AA; y++)
    {
      vec2 p = vec2(x,y);
      vec2 samplePos = (g + p / float(AA));    

      float heightCenter = getTrail(samplePos).z;
      float heightDx = getTrail(samplePos + vec2(1,0)).z;
      float heightDy = getTrail(samplePos + vec2(0,1)).z;        
      float gradientX = (heightCenter-heightDx)/pixelSize;
      float gradientY = (heightCenter-heightDy)/pixelSize;
      vec3 surfaceNormal = normalize(vec3(-gradientX,-gradientY, uNormalDirection));  

      float diffuseFactor = max(dot(vec3(0,0,1), surfaceNormal), 0.0);

      float specularFactor = pow(
        max(dot(theme.lightDirection, reflect(vec3(0,0,1),surfaceNormal)), 0.0), 
        theme.specularPower
      );        

      vec3 baseCol = getTrail(samplePos).rgb;
      vec3 bgCol = vec3(0);	
      bgCol += sin(baseCol.x*4.0 + theme.colorX * 10.0)*.25;
      bgCol += sin(baseCol.y*4.0 + theme.colorY * 10.0)*.25;
      bgCol += sin(baseCol.z*4.0 + theme.colorZ * 10.0)*.25;
      bgCol += 0.6;
      bgCol += (1.0 - baseCol.z) * 3.5;	
      gl_FragColor.rgb += bgCol * (1.0-theme.lightIntensity);
      gl_FragColor.rgb += theme.lightIntensity * (theme.diffuseColor * diffuseFactor +
                                                  theme.specularColor * specularFactor);
    }
    
  gl_FragColor /= float(AA * AA * 4);
  gl_FragColor *= 1.5;
}
